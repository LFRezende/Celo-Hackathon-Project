{
  "language": "Solidity",
  "sources": {
    "contracts/Main.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\nimport \"./Proxy.sol\";\n\ncontract Main {\n    // Boss delegates to a subordinate an amount (to be transfered to new contract)\n\n    // Mappings Main\n    mapping(address => mapping(uint256 => address)) public ownerToContract;\n    mapping(address => uint256) public amountOfContracts;\n    mapping(address => address) public ownerOfContract; // Gets the owner of the contract\n    mapping(address => bool) public addressDelegated;\n    mapping(address => bool) public addressReceived;\n\n    // Events\n    event delegationConfirmed(\n        address indexed owner,\n        address payable[] indexed delegated,\n        address payable[] indexed receivers\n    );\n\n    // Modifiers:\n    modifier onlyOwner(address payable _rxContract) {\n        require(\n            ownerOfContract[_rxContract] == msg.sender,\n            \"Only owner can call this function\"\n        );\n        _;\n    }\n\n    modifier alreadyDelegated(address payable _delegated) {\n        require(\n            !addressDelegated[_delegated],\n            \"Address already delegated - no re-ups.\"\n        );\n        _;\n    }\n\n    modifier alreadyReceived(address payable _rx) {\n        require(\n            !addressReceived[_rx],\n            \"Address of receiver has already been appended - no re-ups.\"\n        );\n        _;\n    }\n\n    function delegate(\n        address payable[] calldata _delegate,\n        address payable[] calldata _allowedRx,\n        uint256[] calldata _amountRx\n    ) public returns (address payable) {\n        Proxy proxy_contract = new Proxy(\n            payable(msg.sender),\n            _delegate,\n            _allowedRx,\n            _amountRx\n        ); // New contract\n        address payable proxy_address = payable(address(proxy_contract));\n\n        ownerToContract[msg.sender][\n            amountOfContracts[msg.sender]\n        ] = proxy_address;\n        amountOfContracts[msg.sender] += 1;\n        ownerOfContract[proxy_address] = msg.sender;\n        for (uint256 j = 0; j < _delegate.length; j++) {\n            addressDelegated[_delegate[j]] = true;\n        }\n        for (uint256 k = 0; k < _allowedRx.length; k++) {\n            addressReceived[_allowedRx[k]] = true;\n        }\n\n        emit delegationConfirmed(msg.sender, _delegate, _allowedRx);\n        return proxy_address;\n    }\n\n    function fundContract(\n        address payable _rxContract\n    ) public payable onlyOwner(_rxContract) returns (bool success) {\n        (success, ) = _rxContract.call{value: msg.value}(\"\");\n        require(success, \"Transaction Failed my son\");\n        return success;\n    }\n\n    function addDelegated(\n        address payable _newDelegate,\n        address payable _contractAddress\n    ) public onlyOwner(_contractAddress) alreadyDelegated(_newDelegate) {\n        Proxy proxy = Proxy(_contractAddress);\n        proxy.insertDelegated(_newDelegate);\n        addressDelegated[_newDelegate] = true;\n    }\n\n    function addReceiver(\n        address payable _rx,\n        address payable _contractAddress\n    ) public onlyOwner(_contractAddress) alreadyReceived(_rx) {\n        Proxy proxy = Proxy(_contractAddress);\n        proxy.insertReceiver(_rx);\n        addressReceived[_rx] = true;\n    }\n\n    function deleteReceiver(\n        address payable _rx,\n        address payable _contractAddress\n    ) public onlyOwner(_contractAddress) {\n        require(\n            addressReceived[_rx],\n            \"Can't delete receiver that has not been appended.\"\n        );\n        Proxy proxy = Proxy(_contractAddress);\n        proxy.eraseReceiver(_rx);\n        addressReceived[_rx] = false;\n    }\n\n    function deleteDelegate(\n        address payable _delegate,\n        address payable _contractAddress\n    ) public onlyOwner(_contractAddress) {\n        require(\n            addressReceived[_delegate],\n            \"Can't delete receiver that has not been appended.\"\n        );\n        Proxy proxy = Proxy(_contractAddress);\n        proxy.eraseDelegate(_delegate);\n        addressDelegated[_delegate] = false;\n    }\n\n    function getLastDelegateContract(\n        address payable owner\n    ) public view returns (address) {\n        require(ownerToContract[owner][0] != address(0), \"Nope.\");\n        uint256 index;\n        for (uint256 j = 0; ownerToContract[owner][j] != address(0); j++) {\n            index = j;\n        }\n        return ownerToContract[owner][index];\n    }\n\n    function getNumber() public view returns (uint256) {\n        uint256 x = amountOfContracts[address(0)];\n        return x;\n    }\n\n    fallback() external payable virtual {}\n\n    receive() external payable virtual {}\n}\n"
    },
    "contracts/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ncontract Proxy {\n    // Global Variables\n    address public immutable delegator;\n    address public immutable rootContract;\n    address payable[] public delegated;\n    address payable[] public allowed_rx;\n\n    // Mappings\n    mapping(address => uint256) public permittedAmount;\n    mapping(address => bool) public rxAllowed;\n    mapping(address => uint256) public rxIndex;\n    mapping(address => uint256) public delIndex;\n    mapping(address => bool) public isDelegated;\n\n    // Modifiers:\n\n    modifier onlyRoot() {\n        require(\n            msg.sender == rootContract,\n            \"Only root contract - not allowed.\"\n        );\n        _;\n    }\n\n    modifier AllowedRx(address payable _wallet) {\n        require(\n            rxAllowed[_wallet],\n            \"Receiver is not allowed - talk to delegator. \"\n        );\n        _;\n    }\n\n    modifier AmountPermitted(uint256 _amount, address payable _wallet) {\n        require(\n            _amount <= permittedAmount[_wallet],\n            \"Surpasses allowed bugdet\"\n        );\n        _;\n    }\n\n    modifier OnlyDelegated() {\n        require(\n            isDelegated[msg.sender],\n            \"This account is not delegated - permission denied.\"\n        );\n        _;\n    }\n\n    // Constructor\n    constructor(\n        address payable _delegator,\n        address payable[] memory _delegated,\n        address payable[] memory _allowed_rx,\n        uint256[] memory _amountRx\n    ) {\n        rootContract = msg.sender;\n        delegator = _delegator; // Beware: Msg.sender is the contract, not the owner.\n        delegated = _delegated;\n        allowed_rx = _allowed_rx;\n        for (uint256 i = 0; i < _amountRx.length; i++) {\n            permittedAmount[_allowed_rx[i]] = _amountRx[i];\n            rxAllowed[_allowed_rx[i]] = true;\n            rxIndex[_allowed_rx[i]] = i;\n        }\n        for (uint256 j = 0; j < _delegated.length; j++) {\n            isDelegated[_delegated[j]] = true;\n            delIndex[_delegated[j]] = j;\n        }\n        // The owner is not allowed to receive it back from the delegate, but is allowed to withdraw at any time.\n        // After all, if he could not, we would burn cash.\n    }\n\n    // Functions\n\n    function transferToPermitted(\n        address payable _rx,\n        uint256 _amount\n    )\n        public\n        payable\n        OnlyDelegated\n        AllowedRx(_rx)\n        AmountPermitted(_amount, _rx)\n        returns (bool success)\n    {\n        // At every transaction, to a specific address, the limited budget decreases. It will require more\n        // cash from the owner and a further permission to use it later.\n        (success, ) = _rx.call{value: _amount}(\"\");\n        require(success, \"Transfer failed\");\n        permittedAmount[_rx] -= _amount;\n        return success;\n    }\n\n    function insertDelegated(address payable _newDelegated) external onlyRoot {\n        delegated.push(_newDelegated);\n        isDelegated[_newDelegated] = true;\n    }\n\n    function insertReceiver(address payable _newRx) external onlyRoot {\n        allowed_rx.push(_newRx);\n        rxAllowed[_newRx] = true;\n    }\n\n    function eraseReceiver(address payable _oldRx) external onlyRoot {}\n\n    function eraseDelegate(address payable _oldDelegate) external onlyRoot {}\n\n    fallback() external payable virtual {}\n\n    receive() external payable virtual {}\n}\n"
    }
  },
  "settings": {
    "evmVersion": "paris",
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}